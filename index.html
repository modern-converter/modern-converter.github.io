<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>File Tool — DARMOWY Konwerter plików online | Konwersja obrazów, audio, dokumentów i wideo lokalnie</title>
<meta name="description" content="Filetool to szybki, darmowy i bezpieczny konwerter plików online. Konwertuj obrazy, audio, dokumenty, archiwa i wideo lokalnie w przeglądarce — bez wysyłania plików na serwer. Obsługa: PNG, JPG, WebP, AVIF, PDF, TXT, MD, CSV, JSON, MP3, WAV, OGG, FLAC, MP4, WebM, GIF i więcej.">
<link rel="canonical" href="https://filetool.pl">
<meta name="robots" content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1">
<meta name="keywords" content="konwerter plików, konwerter obrazów, konwersja audio, pdf online, webp, avif, webm, docx do pdf, jpg do png, wav do mp3, kompresja zdjęć, przeglądarkowy konwerter, bezpieczna konwersja, offline, prywatność, csv do xlsx, markdown do pdf, mp4 do webm, gif tworzenie, zip online, tar, md do html">
<link rel="icon" href="#" id="dynamic-favicon">
<style>
  :root{
    --bg1: 225 70% 3%;
    --glass: 215 40% 95%;
    --glass-2: 215 40% 90%;
    --accent: 195 100% 50%;
    --accent-2: 280 100% 70%;
    --ok: 150 70% 45%;
    --warn: 35 100% 50%;
    --err: 0 80% 55%;
    --shadow: 0 0% 0% / 0.35;
    --blur: 18px;
    --radius: 18px;
    --radius-lg: 26px;
    --ring: 0 0% 100%/0.25;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    color: hsl(0 0% 98%);
    background:
      radial-gradient(1200px 800px at 10% 10%, hsl(200 80% 10% / .55), transparent 60%),
      radial-gradient(1200px 800px at 90% 10%, hsl(280 60% 12% / .50), transparent 60%),
      radial-gradient(1200px 800px at 50% 100%, hsl(190 80% 12% / .50), transparent 60%),
      linear-gradient(180deg, hsl(var(--bg1)), hsl(230 70% 6%));
    overflow-x:hidden;
  }
  .bg-orbs{
    position: fixed;
    inset: -20vmax -20vmax auto auto;
    width: 140vmax; height: 140vmax;
    pointer-events:none;
    filter: blur(60px) saturate(120%);
    opacity:.65;
    mix-blend-mode: screen;
    animation: float 20s ease-in-out infinite alternate;
    background:
      radial-gradient(circle at 20% 30%, hsl(var(--accent)/.35), transparent 25%),
      radial-gradient(circle at 70% 40%, hsl(var(--accent-2)/.35), transparent 28%),
      radial-gradient(circle at 50% 70%, hsl(160 100% 50%/.25), transparent 30%);
  }
  @keyframes float{
    from{transform: translate3d(0,0,0) rotate(0deg)}
    to{transform: translate3d(2vmax,-2vmax,0) rotate(8deg)}
  }

  .nav{
    position: sticky; top:0; z-index:10;
    display:flex; align-items:center; gap:14px;
    padding: 12px clamp(16px, 3vw, 36px);
    backdrop-filter: blur(16px) saturate(150%);
    -webkit-backdrop-filter: blur(16px) saturate(150%);
    background: linear-gradient(180deg, hsl(0 0% 100%/.06), transparent);
    border-bottom: 1px solid hsl(0 0% 100%/.08);
  }
  .brand{display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.3px}
  .logo{
    width:28px; height:28px; border-radius:8px;
    background: conic-gradient(from 210deg, hsl(var(--accent)), hsl(var(--accent-2)), hsl(160 100% 50%), hsl(var(--accent)));
    position: relative;
    box-shadow: 0 6px 24px hsl(var(--accent)/.35), inset 0 0 0 1px hsl(0 0% 100%/.25);
  }
  .logo::after{
    content:""; position:absolute; inset:4px; border-radius:6px;
    background: radial-gradient(circle at 30% 30%, #fff6, transparent 60%);
    mix-blend-mode: overlay;
  }
  .nav .links{display:flex; gap:10px; flex-wrap:wrap; margin-left:auto}
  .chip{
    display:inline-flex; align-items:center; gap:8px;
    padding:8px 12px; border-radius:999px;
    border:1px solid hsl(0 0% 100%/.15);
    background: linear-gradient(180deg, hsl(0 0% 100%/.10), hsl(0 0% 100% / .05));
    color:white; text-decoration:none; cursor:pointer;
    transition: .2s transform, .2s filter, .2s box-shadow;
  }
  .chip[aria-current="page"], .chip.active{
    box-shadow: 0 6px 20px hsl(var(--accent)/.25), inset 0 1px 0 hsl(0 0% 100% / .25);
    background: linear-gradient(180deg, hsl(var(--accent)/.85), hsl(var(--accent)/.7));
    border-color: transparent;
  }
  .chip:active{ transform: translateY(1px) }

  .container{display:grid;place-items:center;padding: clamp(12px, 2.8vw, 40px)}
  .app{width: min(1040px, 100%);display:grid;gap:22px}
  .hero{display:grid;gap:10px;text-align:center}
  .hero h1{
    margin:0;font-weight:800;letter-spacing:.2px;font-size: clamp(26px, 5.5vw, 44px);
    background: linear-gradient(90deg, hsl(var(--glass)/.96), hsl(var(--accent)/.9), hsl(var(--accent-2)/.9));
    -webkit-background-clip:text;background-clip:text;color: transparent;
    filter: drop-shadow(0 4px 24px hsl(200 100% 60% / .15));
  }
  .hero p{margin:0 auto;max-width: 68ch;color: hsl(0 0% 90%);opacity:.9;padding: 0 8px}

  .panel{
    position: relative; display:grid; gap: 14px;
    padding: clamp(14px, 2.8vw, 28px);
    background: linear-gradient(180deg, hsl(var(--glass)/.16), hsl(var(--glass-2)/.08));
    border-radius: var(--radius-lg);
    border: 1px solid hsl(0 0% 100% / .08);
    backdrop-filter: blur(var(--blur)) saturate(140%);
    -webkit-backdrop-filter: blur(var(--blur)) saturate(140%);
    box-shadow: 0 10px 30px hsl(var(--shadow)), inset 0 1px 0 hsl(var(--ring));
  }
  .panel .title{display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.3px}
  .title .dot{
    width:10px; height:10px; border-radius:999px;
    background: radial-gradient(circle at 30% 30%, hsl(var(--accent)/1), hsl(var(--accent)/.5));
    box-shadow: 0 0 22px hsl(var(--accent)/.8), 0 0 4px 1px hsl(0 0% 100% / .2) inset;
  }

  .drop{
    position: relative;border: 1px dashed hsl(0 0% 100% / .25);
    border-radius: var(--radius);padding: clamp(14px, 2.2vw, 24px);min-height: 200px;
    display:grid;place-items:center;gap:12px;text-align:center;
    transition: .25s border-color, .25s box-shadow, .25s transform;
    background: linear-gradient(180deg, hsl(var(--glass)/.12), hsl(var(--glass-2)/.06));
  }
  .drop.drag{
    border-color: hsl(var(--accent));
    box-shadow: 0 0 0 6px hsl(var(--accent)/.18) inset, 0 10px 30px hsl(var(--accent)/.15);
    transform: translateY(-2px);
  }
  .drop .big{font-size: clamp(18px, 2.6vw, 22px);font-weight:700}
  .drop .small{opacity:.8}
  .drop .btn{margin-top:8px}
  input[type="file"]{position:absolute;inset:0;opacity:0;cursor:pointer}
  .btn{
    display:inline-grid; place-items:center; padding: 14px 22px; border-radius: 14px;
    border: 1px solid hsl(0 0% 100% / .2); color: white;
    background: linear-gradient(180deg, hsl(var(--accent)/.9), hsl(var(--accent)/.75));
    box-shadow: 0 8px 20px hsl(var(--accent)/.25), inset 0 1px 0 hsl(0 0% 100% / .25);
    cursor:pointer; user-select:none; transition: .2s transform, .2s box-shadow, .2s filter;
  }
  .btn:active{ transform: translateY(1px); filter: saturate(120%) }
  .btn.secondary{ background: linear-gradient(180deg, hsl(0 0% 100% / .09), hsl(0 0% 100% / .04)); color: hsl(0 0% 98%) }
  .row{display:flex; gap:10px; flex-wrap: wrap; align-items:center}

  footer{display:flex; justify-content:center; gap:10px; flex-wrap:wrap; opacity:.9; font-size:12px; padding: 6px 0 24px}

  .page{ display:none }
  .page.active{ display:block }

  .format-selector{ display:grid; gap:10px; }
  .format-groups{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
  .fchip{
    border-radius: 999px; padding:8px 12px; cursor:pointer;
    border:1px solid hsl(0 0% 100%/.18);
    background: linear-gradient(180deg, hsl(0 0% 100%/.12), hsl(0 0% 100%/.06));
    transition:.2s transform, .2s box-shadow, .2s opacity;
    font-weight:600; letter-spacing:.2px;
  }
  .fchip:active{ transform: translateY(1px) }
  .fchip[aria-pressed="true"]{
    background: linear-gradient(180deg, hsl(var(--accent)/.95), hsl(var(--accent)/.8));
    border-color: transparent;
    box-shadow: 0 6px 18px hsl(var(--accent)/.35);
  }
  .fchip[disabled]{ opacity:.45; cursor:not-allowed; filter: grayscale(.3); }
  .format-options{
    display:flex; gap:8px; flex-wrap:wrap; justify-content:center;
  }
  .format-option{
    padding:10px 12px; border-radius:12px; cursor:pointer;
    border:1px solid hsl(0 0% 100%/.15);
    background: linear-gradient(180deg, hsl(0 0% 100%/.11), hsl(0 0% 100%/.05));
    transition:.2s transform, .2s box-shadow, .2s opacity, .2s filter;
  }
  .format-option[aria-checked="true"]{
    background: linear-gradient(180deg, hsl(var(--accent)/.9), hsl(var(--accent)/.75));
    border-color: transparent;
    box-shadow: 0 8px 20px hsl(var(--accent)/.25);
  }
  .format-option[disabled]{ opacity:.45; cursor:not-allowed; filter: grayscale(.3) }
  .convert-wrap{ display:grid; place-items:center; margin-top:8px; }
  #convertBtn{ font-size: clamp(16px, 2.6vw, 18px); padding: 16px 28px; min-width: 240px; }

  /* SEO sections */
  .content-grid{display:grid; gap:16px; grid-template-columns: 1.1fr 1fr}
  @media (max-width: 980px){ .content-grid{grid-template-columns: 1fr} }
  .kpi{display:grid; grid-template-columns: repeat(3, 1fr); gap:10px}
  @media (max-width: 560px){ .kpi{grid-template-columns: 1fr 1fr} }
  .kpi .panel{ text-align:center; padding:18px }

  /* Progress page */
  #page-progress .progress-wrap{display:grid; gap:14px}
  .big-title{font-weight:800; font-size: clamp(20px, 4.6vw, 28px)}
  .btn-row{ display:flex; gap:10px; flex-wrap:wrap }
  .prog{
    --p:0%; height: 12px; border-radius: 999px; background: hsl(0 0% 100% / .08);
    border: 1px solid hsl(0 0% 100% / .12); overflow:hidden;
  }
  .prog > i{
    display:block; height:100%; width: var(--p);
    background: linear-gradient(90deg, hsl(var(--accent)), hsl(var(--accent-2)));
    box-shadow: 0 0 20px hsl(var(--accent)/.55);
    transition: width .2s linear;
  }

  /* Layout helpers */
  #home-grid{ display:grid; gap:24px; }
  .ghost{ opacity:.7 }
  .file-list{display:grid; gap:10px; margin-top:6px; max-height: 240px; overflow:auto; padding-right:4px}
  .file{
    display:grid; grid-template-columns: auto 1fr auto; gap:10px; align-items:center;
    padding:10px 12px; border-radius: 12px;
    background: linear-gradient(180deg, hsl(0 0% 100% / .10), hsl(0 0% 100% / .05));
    border: 1px solid hsl(0 0% 100% / .15);
  }
  .file .icon{
    width:34px; height:34px; border-radius:10px; flex:none;
    background: radial-gradient(circle at 30% 30%, hsl(var(--accent)/.9), hsl(var(--accent-2)/.8));
    box-shadow: 0 6px 18px hsl(var(--accent)/.35);
  }
  .file .meta{display:flex; flex-direction:column; gap:2px}
  .file .meta b{ font-size:14px }
  .file .meta small{ opacity:.85 }
  .status{font-size:12px; padding:6px 8px; border-radius:999px; border: 1px solid hsl(0 0% 100% / .18)}
  .ok{ background: hsl(var(--ok)/.15); border-color: hsl(var(--ok)/.35) }
  .warn{ background: hsl(var(--warn)/.15); border-color: hsl(var(--warn)/.35) }
  .err{ background: hsl(var(--err)/.15); border-color: hsl(var(--err)/.35) }

  /* Hide settings initially per request */
  #settings-panel{ display:none; }

  /* Also hide inline progress / results / clear initially */
  #inline-progress-row, #results-section, #clearBtn { display:none !important; }
</style>

<script type="importmap">
{
  "imports": {}
}
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1712836182508924" crossorigin="anonymous"></script>
</head>
<body>
<div class="bg-orbs" aria-hidden="true"></div>

<header class="nav" role="navigation" aria-label="Nawigacja główna">
  <div class="brand">
    <div class="logo" aria-hidden="true"></div>
    <span>File Tool</span>
  </div>
  <nav class="links" aria-label="Linki">
    <a class="chip" data-route="home" aria-current="page">Konwerter</a>
    <a class="chip" data-route="about">O projekcie</a>
    <a class="chip" data-route="security">Bezpieczeństwo</a>
    <a class="chip" data-route="help">Pomoc</a>
  </nav>
</header>

<main class="container">
  <div class="app">

    <section class="hero">
      <h1>DARMOWY Konwerter plików FileTool</h1>
      <p>Konwertuj obrazy, audio, dokumenty, archiwa i wideo bezpośrednio w przeglądarce. Zero wysyłania plików — pełna prywatność.</p>
      <p class="ghost" style="margin-top:6px">Szybka i bezpieczna konwersja online • 100% lokalnie • Bez konta</p>
      <p class="ghost" style="margin-top:6px">Obsługiwane formaty: PNG, JPG, JPEG, WebP, AVIF, GIF, MP4, WebM, MOV, WAV, MP3, M4A, OGG, FLAC, TXT, MD, RTF, PDF, CSV, JSON, ZIP (lite) i inne.</p>
    </section>

    <section class="page active" id="page-home" aria-label="Konwerter">
      <div id="home-grid">
        <section class="panel" aria-label="Przesyłanie">
          <div class="title"><span class="dot"></span> Prześlij pliki</div>
          <div id="drop" class="drop" tabindex="0" role="button" aria-label="Przeciągnij i upuść pliki lub wybierz z dysku">
            <input id="fileInput" type="file" multiple aria-label="Wybór plików">
            <div class="big">Przeciągnij i upuść pliki tutaj</div>
            <div class="small">albo</div>
            <div class="btn">Przeglądaj pliki</div>
            <div class="row" style="justify-content:center; gap:8px; margin-top:6px">
              <span class="status ok">Lokalna konwersja</span>
              <span class="status">Brak limitów chmury</span>
            </div>
            <div class="row" id="limitInfo" style="justify-content:center; gap:8px; margin-top:6px">
              <span class="status">Automatyczny limit urządzenia</span>
            </div>
          </div>
          <div class="file-list" id="fileList" aria-live="polite"></div>
        </section>

        <section class="panel" id="settings-panel" aria-label="Ustawienia">
          <div class="title"><span class="dot"></span> Ustaw format</div>
          <div class="format-selector" aria-label="Wybierz kategorię i format">
            <div class="format-groups" id="formatGroups" role="tablist" aria-label="Kategorie"></div>
            <div class="format-options" id="formatOptions" role="radiogroup" aria-label="Format wyjściowy"></div>
            <div class="convert-wrap">
              <button id="convertBtn" class="btn" aria-label="Rozpocznij konwersję">Konwertuj</button>
            </div>
            <div class="row" id="inline-progress-row" style="margin-top:6px">
              <div class="prog" style="flex:1"><i id="progressBar" style="width:0%"></i></div>
              <span id="progressText" style="min-width:110px; text-align:right">0%</span>
              <button id="clearBtn" class="btn secondary" aria-label="Wyczyść listę">Wyczyść</button>
            </div>
          </div>
        </section>

        <section class="panel" id="results-section" aria-label="Wyniki">
          <div class="title"><span class="dot"></span> Wyniki</div>
          <div class="file-list" id="resultList"></div>
        </section>
      </div>
    </section>

    <section class="page" id="page-progress" aria-label="Trwa konwersja">
      <section class="panel">
        <div class="title"><span class="dot"></span> Konwersja</div>
        <div class="progress-wrap">
          <div class="big-title" id="progressTitle">Pracujemy nad Twoimi plikami…</div>
          <div class="row">
            <div class="prog" style="flex:1"><i id="progressBar2" style="width:0%"></i></div>
            <span id="progressText2" style="min-width:110px; text-align:right">0%</span>
          </div>
          <div class="btn-row">
            <a id="downloadAll" class="btn" download>Pobierz</a>
            <button id="convertMore" class="btn secondary">Wróć</button>
          </div>
          <div class="ghost" id="progressHint">Pozostaw kartę otwartą — konwersja odbywa się lokalnie. Po pobraniu możesz wrócić i zacząć od nowa.</div>
        </div>
      </section>
    </section>

    <section class="page" id="page-about" aria-label="O projekcie">
      <div class="content-grid">
        <div class="panel">
          <div class="title"><span class="dot"></span> O Filetool</div>
          <p>Filetool to prywatny, działający na urządzeniu konwerter plików. Działa całkowicie w przeglądarce, używając Web API i opcjonalnie silnika FFmpeg do przetwarzania bez wysyłania danych.</p>
          <p>Stawiamy na bezpieczeństwo, szybkość i prostotę. Interfejs jest intuicyjny: prześlij plik, dopiero potem wybierz format i kliknij „Konwertuj”. Wynik pobierzesz na osobnej stronie postępu.</p>
          <div class="kpi">
            <div class="panel"><div class="big" style="font-weight:800; font-size:22px">100% Lokalnie</div><div class="subtle">Brak wysyłek</div></div>
            <div class="panel"><div class="big" style="font-weight:800; font-size:22px">Adaptacyjnie</div><div class="subtle">Bezpieczne limity</div></div>
            <div class="panel"><div class="big" style="font-weight:800; font-size:22px">Standardy</div><div class="subtle">Web API + FFmpeg</div></div>
          </div>
        </div>
        <div class="panel">
          <div class="title"><span class="dot"></span> Dlaczego warto</div>
          <ul>
            <li>Prywatność: nic nie trafia do chmury.</li>
            <li>Uniwersalność: obsługa popularnych formatów grafiki, audio, wideo i dokumentów.</li>
            <li>Wydajność: brak uploadu, szybkie działanie.</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="page" id="page-security" aria-label="Bezpieczeństwo">
      <div class="content-grid">
        <div class="panel">
          <div class="title"><span class="dot"></span> Bezpieczeństwo i prywatność</div>
          <ul>
            <li>Pliki nie opuszczają urządzenia. Wszystko dzieje się w przeglądarce.</li>
            <li>Brak kont i logowania.</li>
            <li>Heurystyki pamięci dbają o responsywność urządzenia.</li>
            <li>Piaskownica przeglądarki — brak dodatkowych uprawnień.</li>
          </ul>
        </div>
        <div class="panel">
          <div class="title"><span class="dot"></span> Najlepsze praktyki</div>
          <ul>
            <li>Wybieraj nowoczesne formaty (WebP/AVIF dla obrazów, WebM dla wideo).</li>
            <li>Redukuj rozdzielczość/bitrate, by przyspieszyć konwersję na słabszych urządzeniach.</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="page" id="page-help" aria-label="Pomoc">
      <div class="panel">
        <div class="title"><span class="dot"></span> Szybki start</div>
        <ol>
          <li>Przeciągnij i upuść pliki lub wybierz z dysku.</li>
          <li>Wybierz format wyjściowy.</li>
          <li>Kliknij „Konwertuj”. Otworzy się strona postępu z paskiem.</li>
          <li>Po zakończeniu pobierz wynik lub wróć do startu (reset).</li>
        </ol>
      </div>
      <div class="panel">
        <div class="title"><span class="dot"></span> FAQ</div>
        <p><b>Czy pliki są wysyłane do Internetu?</b> Nie — przetwarzamy lokalnie.</p>
        <p><b>Dlaczego niektóre formaty mają dopisek „lite”?</b> To lekkie, zgodne substytuty tworzone w przeglądarce, gdy pełne kodowanie nie jest dostępne.</p>
      </div>
    </section>

    <footer>
      <span>Działa w 100% lokalnie • Brak wysyłania plików</span>
      <span>Prosty interfejs: najpierw prześlij • potem wybierz • konwertuj</span>
    </footer>
  </div>
</main>

<script type="module">
/* Dynamic favicon (procedurally generated) */
(function(){
  const c = document.createElement('canvas');
  c.width = 64; c.height = 64;
  const ctx = c.getContext('2d');
  const g = ctx.createConicGradient(Math.PI*0.6, 32, 32);
  g.addColorStop(0, '#22d3ee'); g.addColorStop(0.5, '#a78bfa'); g.addColorStop(1, '#22d3ee');
  ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
  ctx.fillStyle = 'rgba(255,255,255,.9)';
  ctx.beginPath();
  ctx.roundRect(14,14,36,36,8);
  ctx.strokeStyle = 'rgba(255,255,255,.9)'; ctx.lineWidth = 3; ctx.stroke();
  ctx.font = 'bold 20px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('F', 32, 34);
  const link = document.getElementById('dynamic-favicon');
  link.href = c.toDataURL('image/png');
})();

/* FFmpeg loader (non-blocking with timeout + graceful fallback to "lite" modes) */
let ffmpeg = null, fetchFileFunc = null, ffmpegLoaderPromise = null, ffmpegAvailable = false;
const FF_VER = '0.12.6';
function loadFFmpegLibrary() {
  if (window.FFmpeg && window.FFmpeg.createFFmpeg && window.FFmpeg.fetchFile) return Promise.resolve();
  if (ffmpegLoaderPromise) return ffmpegLoaderPromise;
  ffmpegLoaderPromise = new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = `https://unpkg.com/@ffmpeg/ffmpeg@${FF_VER}/dist/ffmpeg.min.js`;
    s.crossOrigin = 'anonymous';
    s.async = true;
    s.onload = () => {
      if (window.FFmpeg && FFmpeg.createFFmpeg) resolve();
      else reject(new Error('FFmpeg globals missing'));
    };
    s.onerror = () => reject(new Error('FFmpeg script load error'));
    document.head.appendChild(s);
  });
  return ffmpegLoaderPromise;
}
function withTimeout(promise, ms, label='operation'){
  return new Promise((resolve, reject)=>{
    const t = setTimeout(()=>reject(new Error(`${label} timeout after ${ms}ms`)), ms);
    promise.then(v=>{ clearTimeout(t); resolve(v); }, e=>{ clearTimeout(t); reject(e); });
  });
}
const ffmpegReadyPromise = (async () => {
  try {
    await withTimeout(loadFFmpegLibrary(), 8000, 'FFmpeg script load');
    const { createFFmpeg, fetchFile } = FFmpeg;
    fetchFileFunc = fetchFile;
    ffmpeg = createFFmpeg({ log: false, corePath: `https://unpkg.com/@ffmpeg/core@${FF_VER}/dist/ffmpeg-core.js` });
    await withTimeout(ffmpeg.load(), 12000, 'FFmpeg core load');
    ffmpegAvailable = true;
  } catch (e) {
    console.warn('FFmpeg init failed, using lite fallbacks:', e);
    ffmpegAvailable = false;
  }
})();
async function ensureFFmpegReady(){ try{ await ffmpegReadyPromise; }catch{} return ffmpegAvailable; }
async function ffmpegConvert(file, outputFmt){
  const ok = await ensureFFmpegReady();
  if(!ok) throw new Error('ffmpeg not available');
  const inputExt = (file.name.split('.').pop() || 'dat').toLowerCase();
  const inName = `input.${inputExt}`;
  const outName = `output.${outputFmt}`;
  ffmpeg.FS('writeFile', inName, await fetchFileFunc(file));
  const args = buildFFArgs(inName, outName, outputFmt);
  await withTimeout(ffmpeg.run(...args), 30000, 'FFmpeg run');
  const data = ffmpeg.FS('readFile', outName);
  try{ ffmpeg.FS('unlink', inName); }catch{}
  try{ ffmpeg.FS('unlink', outName); }catch{}
  return new Blob([data.buffer], {type: fmtToMime(outputFmt)});
}
function buildFFArgs(inName, outName, fmt){
  switch(fmt){
    case 'mp3': return ['-i', inName, '-codec:a', 'libmp3lame', '-qscale:a', '2', outName];
    case 'm4a': return ['-i', inName, '-c:a', 'aac', '-b:a', '160k', outName];
    case 'ogg': return ['-i', inName, '-c:a', 'libvorbis', '-qscale:a', '5', outName];
    case 'flac': return ['-i', inName, '-c:a', 'flac', outName];
    case 'opus': return ['-i', inName, '-c:a', 'libopus', '-b:a', '128k', outName];
    case 'mp4': return ['-i', inName, '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23', '-c:a', 'aac', '-b:a', '128k', outName];
    case 'webm': return ['-i', inName, '-c:v', 'libvpx-vp9', '-b:v', '0', '-crf', '32', '-c:a', 'libopus', outName];
    case 'gif': return ['-i', inName, '-vf', 'fps=12,scale=480:-1:flags=lanczos', '-loop', '0', outName];
    case 'mov': return ['-i', inName, '-c:v', 'libx264', '-crf', '22', '-c:a', 'aac', outName];
    default: return ['-i', inName, outName];
  }
}

/* DOM helpers */
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));

/* Router */
const routes = ['home','progress','about','security','help'];
const chips = $$('.chip[data-route]');
chips.forEach(ch => ch.addEventListener('click', e=>{
  e.preventDefault();
  navigate(ch.getAttribute('data-route'));
}));
function navigate(route){
  routes.forEach(r=>{
    const page = $('#page-'+r);
    if(!page) return;
    page.classList.toggle('active', r===route);
    const chip = document.querySelector('.chip[data-route="'+r+'"]');
    if(chip){
      if(r===route){ chip.classList.add('active'); chip.setAttribute('aria-current','page'); }
      else{ chip.classList.remove('active'); chip.removeAttribute('aria-current'); }
    }
  });
  try{ history.replaceState({}, '', '#'+route); }catch{}
}
window.addEventListener('popstate', ()=> navigate((location.hash||'#home').slice(1)));
navigate((location.hash||'#home').slice(1));

/* Elements */
const dropEl = $('#drop');
const fileInput = $('#fileInput');
const fileListEl = $('#fileList');
const resultListEl = $('#resultList');

const progressBar = $('#progressBar');
const progressText = $('#progressText');
const convertBtn = $('#convertBtn');

const progressBar2 = $('#progressBar2');
const progressText2 = $('#progressText2');
const progressTitle = $('#progressTitle');
const downloadAllBtn = $('#downloadAll');
const convertMoreBtn = $('#convertMore');

const KB = 1024, MB = 1024*KB, GB = 1024*MB;

/* Formats — expanded */
const formatGroupsEl = $('#formatGroups');
const formatOptionsEl = $('#formatOptions');

const formatsCatalog = {
  image: { label: 'Obraz', formats: ['png','jpeg','webp','avif','png-8','jpeg-low','gif','bmp-lite','svg-lite','ico-lite'] },
  audio: { label: 'Audio', formats: ['wav','mp3','m4a','ogg','flac','opus'] },
  video: { label: 'Wideo', formats: ['mp4','webm','gif','gif-lite','webm-lite','thumb-webp','mov'] },
  document: { label: 'Dokument', formats: ['txt','md','pdf-lite','rtf-lite','html-lite'] },
  archive: { label: 'Archiwum', formats: ['zip-lite','tar-lite'] },
  code: { label: 'Dane', formats: ['txt','json','csv','ndjson-lite'] }
};
const extToCategory = {
  png:'image', jpg:'image', jpeg:'image', webp:'image', avif:'image', bmp:'image', gif:'image', svg:'image', ico:'image', heic:'image',
  wav:'audio', mp3:'audio', m4a:'audio', ogg:'audio', flac:'audio', opus:'audio',
  txt:'document', md:'document', html:'document', pdf:'document', rtf:'document', docx:'document',
  json:'code', csv:'code', js:'code', ndjson:'code',
  mp4:'video', webm:'video', mov:'video', mkv:'video', avi:'video', hevc:'video'
};
const labelMap = {
  'png':'PNG (bezstratny)','png-8':'PNG-8 (kompaktowy)','jpeg':'JPEG (wysoka jakość)','jpeg-low':'JPEG (lżejszy)',
  'webp':'WebP','avif':'AVIF (wysoka kompresja)','gif':'GIF','bmp-lite':'BMP (lite)','svg-lite':'SVG (lite)','ico-lite':'ICO (lite)',
  'wav':'WAV (bezstratny)','mp3':'MP3','m4a':'M4A (AAC)','ogg':'OGG','flac':'FLAC (bezstratny)','opus':'OPUS',
  'txt':'TXT','md':'Markdown','pdf-lite':'PDF (lekki)','rtf-lite':'RTF (lekki)','html-lite':'HTML (lekki)',
  'gif-lite':'GIF (lekki)','webm-lite':'WebM (lekki)','thumb-webp':'Miniatura WebP',
  'zip-lite':'ZIP (lekki)','tar-lite':'TAR (lekki)','json':'JSON','csv':'CSV','ndjson-lite':'NDJSON (lekki)',
  'mp4':'MP4 (H.264)','webm':'WebM (VP9)','mov':'MOV'
};

/* Compatibility map: input category -> allowed output categories */
const compatibleCategoryMap = {
  image:    new Set(['image','document','archive','code']), // images to images (or document/html-lite, archive-lite, txt/json/csv OK)
  audio:    new Set(['audio','document','archive','code']), // audio to audio; others as lite wrappers/text metadata
  video:    new Set(['video','image','document','archive','code']), // video -> video, image (thumb/gif), lite docs/archives
  document: new Set(['document','image','archive','code']), // docs to docs, image (svg-lite/png), lite archives/data
  archive:  new Set(['archive']), // archive cannot be transcoded to media
  code:     new Set(['code','document','archive']) // data to data, txt/html-lite, pack
};
/* Per-category, restrict allowed formats further (e.g., video to image only for thumb/gif) */
const perCategoryAllowedFormats = {
  video: new Set(['mp4','webm','gif','gif-lite','webm-lite','thumb-webp','mov']),
  image: new Set(['png','jpeg','webp','avif','png-8','jpeg-low','gif','bmp-lite','svg-lite','ico-lite','pdf-lite','html-lite','zip-lite','tar-lite','txt','json','csv','ndjson-lite']),
  audio: new Set(['wav','mp3','m4a','ogg','flac','opus','zip-lite','tar-lite','txt','json','csv','ndjson-lite']),
  document: new Set(['txt','md','pdf-lite','rtf-lite','html-lite','png','jpeg','webp','svg-lite','zip-lite','tar-lite','json','csv','ndjson-lite']),
  archive: new Set(['zip-lite','tar-lite']), // only repack
  code: new Set(['txt','json','csv','ndjson-lite','html-lite','zip-lite','tar-lite'])
};

let selectedCategory = 'image';
let selectedFormat = 'png';

function buildFormatUI(){
  formatGroupsEl.innerHTML = '';
  for(const [key, val] of Object.entries(formatsCatalog)){
    const btn = document.createElement('button');
    btn.className = 'fchip';
    btn.type = 'button';
    btn.setAttribute('role','tab');
    btn.setAttribute('aria-pressed', key===selectedCategory ? 'true' : 'false');
    btn.textContent = val.label;
    btn.addEventListener('click', ()=>{
      selectedCategory = key;
      refreshGroups();
      buildFormatOptions();
    });
    formatGroupsEl.appendChild(btn);
  }
  buildFormatOptions();
  applyCompatibilityLocks(); // initial lock state
}
function refreshGroups(){
  $$('#formatGroups .fchip').forEach(b=>{
    b.setAttribute('aria-pressed', b.textContent === formatsCatalog[selectedCategory].label ? 'true' : 'false');
  });
}
function buildFormatOptions(){
  formatOptionsEl.innerHTML = '';
  const list = formatsCatalog[selectedCategory].formats;
  if(!list.includes(selectedFormat)) selectedFormat = list[0];
  list.forEach(fmt=>{
    const opt = document.createElement('button');
    opt.className = 'format-option';
    opt.type = 'button';
    opt.setAttribute('role','radio');
    opt.setAttribute('data-fmt', fmt);
    opt.setAttribute('aria-checked', fmt===selectedFormat ? 'true' : 'false');
    opt.textContent = labelMap[fmt] || fmt.toUpperCase();
    opt.addEventListener('click', ()=>{
      if(opt.hasAttribute('disabled')) return;
      selectedFormat = fmt;
      $$('#formatOptions .format-option').forEach(o=>o.setAttribute('aria-checked','false'));
      opt.setAttribute('aria-checked','true');
    });
    formatOptionsEl.appendChild(opt);
  });
  applyCompatibilityLocks();
}

/* Compute dominant input category from current file list */
function currentInputCategory(){
  if(!files.length) return null;
  const count = {image:0,audio:0,document:0,video:0,archive:0,code:0};
  for(const f of files){
    const ext = (f.name.split('.').pop()||'').toLowerCase();
    const cat = extToCategory[ext] || 'document';
    if(count[cat]!==undefined) count[cat]++;
  }
  // Dominant category
  return Object.entries(count).sort((a,b)=>b[1]-a[1])[0][0];
}

/* Deactivate incompatible formats and category chips */
function applyCompatibilityLocks(){
  const inputCat = currentInputCategory();
  // No files: enable everything
  if(!inputCat){
    $$('#formatGroups .fchip').forEach(ch=> ch.removeAttribute('disabled'));
    $$('#formatOptions .format-option').forEach(o=> o.removeAttribute('disabled'));
    return;
  }
  // Lock category chips
  const allowedCats = compatibleCategoryMap[inputCat] || new Set();
  $$('#formatGroups .fchip').forEach(ch=>{
    const cat = Object.keys(formatsCatalog).find(k => formatsCatalog[k].label === ch.textContent);
    if(!cat) return;
    const allowed = allowedCats.has(cat);
    if(!allowed){ ch.setAttribute('disabled',''); }
    else ch.removeAttribute('disabled');
  });
  // Lock format options inside selected category
  const allowedFormatsSet = perCategoryAllowedFormats[inputCat] || new Set();
  $$('#formatOptions .format-option').forEach(o=>{
    const fmt = o.getAttribute('data-fmt');
    const globallyInCategory = (formatsCatalog[selectedCategory]?.formats || []).includes(fmt);
    const allowed = globallyInCategory && allowedFormatsSet.has(fmt);
    if(!allowed){
      o.setAttribute('disabled','');
      if(o.getAttribute('aria-checked')==='true'){
        o.setAttribute('aria-checked','false');
      }
    }else{
      o.removeAttribute('disabled');
    }
  });
  // If current selectedFormat became disabled, choose first enabled
  const enabled = $$('#formatOptions .format-option:not([disabled])');
  if(enabled.length){
    const stillSelected = enabled.find(o=> o.getAttribute('data-fmt')===selectedFormat);
    if(!stillSelected){
      selectedFormat = enabled[0].getAttribute('data-fmt');
      enabled[0].setAttribute('aria-checked','true');
    }
  }
  // Also prevent selecting a disabled category via keyboard focus
  // If the current selectedCategory is not allowed, switch to first allowed category
  if(!allowedCats.has(selectedCategory)){
    const firstAllowed = Object.keys(formatsCatalog).find(cat => allowedCats.has(cat));
    if(firstAllowed){
      selectedCategory = firstAllowed;
      refreshGroups();
      buildFormatOptions();
    }
  }
}

/* Auto category suggestion based on files */
function autoCategoryForFiles(fs){
  if(!fs.length) return 'image';
  const count = {image:0,audio:0,document:0,video:0,archive:0,code:0};
  for(const f of fs){
    const ext = (f.name.split('.').pop() || '').toLowerCase();
    const cat = extToCategory[ext] || 'document';
    if(count[cat]!==undefined) count[cat]++;
  }
  let best = 'image', max = -1;
  for(const k of Object.keys(count)){ if(count[k] > max){ max = count[k]; best = k; } }
  return best;
}

function estimateSafeLimitBytes(){
  const mem = navigator.deviceMemory || 4;
  const cores = (navigator.hardwareConcurrency || 4);
  const ua = navigator.userAgent.toLowerCase();
  const isMobile = /iphone|ipad|android|mobile/.test(ua);
  let base = Math.min(mem * 5, 50) * GB;
  if(isMobile) base *= 0.6;
  if(cores <= 2) base *= 3;
  base = Math.max(200*MB, Math.min(base, 50*GB));
  return Math.round(base);
}
function humanSize(bytes){
  const GBb=1024*1024*1024, MBb=1024*1024, KBb=1024;
  if(bytes >= GBb) return (bytes/GBb).toFixed(2)+' GB';
  if(bytes >= MBb) return (bytes/MBb).toFixed(1)+' MB';
  if(bytes >= KBb) return (bytes/KBb).toFixed(1)+' KB';
  return bytes+' B';
}

/* State */
let files = [];
let results = [];

/* File list rendering */
function onFilesChanged(){
  const settings = document.getElementById('settings-panel');
  if(settings) settings.style.display = files.length ? 'block' : 'none';
  // Re-apply locks based on current files
  applyCompatibilityLocks();
}
function addFiles(newFiles){
  const limitBytes = estimateSafeLimitBytes();
  const currentTotal = files.reduce((a,f)=>a+f.size,0);
  let addedTotal = 0;
  for(const f of newFiles){
    if(files.some(x => x.name===f.name && x.size===f.size)) continue;
    if(currentTotal + addedTotal + f.size > limitBytes){
      toast(`Pominięto ${f.name} (przekracza limit)`, 'warn');
      continue;
    }
    files.push(f);
    addedTotal += f.size;
  }
  renderFileList();
  onFilesChanged();
  const detected = autoCategoryForFiles(files);
  if(detected !== selectedCategory){
    selectedCategory = detected;
    refreshGroups();
    buildFormatOptions();
  } else {
    applyCompatibilityLocks();
  }
}
function renderFileList(){
  fileListEl.innerHTML = '';
  if(!files.length){
    fileListEl.innerHTML = '<div class="ghost">Nie dodano jeszcze żadnych plików.</div>';
    return;
  }
  for(const [i,f] of files.entries()){
    const row = document.createElement('div');
    row.className = 'file';
    row.innerHTML = `
      <div class="icon"></div>
      <div class="meta">
        <b title="${f.name}">${truncate(f.name, 38)}</b>
        <small>${humanSize(f.size)}</small>
      </div>
      <div class="act">
        <span class="status">W kolejce</span>
        <button class="btn secondary" data-remove="${i}" title="Usuń">Usuń</button>
      </div>
    `;
    fileListEl.appendChild(row);
  }
  fileListEl.querySelectorAll('[data-remove]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const idx = +btn.getAttribute('data-remove');
      files.splice(idx,1);
      renderFileList();
      onFilesChanged();
      const detected = autoCategoryForFiles(files);
      if(detected !== selectedCategory){
        selectedCategory = detected;
        refreshGroups();
        buildFormatOptions();
      } else {
        applyCompatibilityLocks();
      }
    });
  });
}
function renderResults(){
  resultListEl.innerHTML = '';
  if(!results.length){
    resultListEl.innerHTML = '<div class="ghost">Przekonwertowane pliki pojawią się tutaj.</div>';
    return;
  }
  for(const r of results){
    const row = document.createElement('div');
    row.className = 'file';
    row.innerHTML = `
      <div class="icon"></div>
      <div class="meta">
        <b title="${r.name}">${truncate(r.name, 38)}</b>
        <small>${humanSize(r.blob.size)} • ${r.type}</small>
      </div>
      <div class="act">
        <a class="btn" download="${r.name}">Pobierz</a>
      </div>
    `;
    const a = row.querySelector('a');
    a.href = URL.createObjectURL(r.blob);
    resultListEl.appendChild(row);
  }
}

/* Toast */
function toast(msg, type='ok'){
  const el = document.createElement('div');
  el.textContent = msg;
  el.className = `status ${type==='ok'?'ok':type==='warn'?'warn':'err'}`;
  el.style.position='fixed';
  el.style.right='16px'; el.style.bottom='16px';
  el.style.zIndex='9999';
  el.style.backdropFilter = 'blur(8px)';
  el.style.padding = '8px 12px';
  el.style.borderRadius = '999px';
  el.style.border = '1px solid rgba(255,255,255,.18)';
  el.style.background = 'linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06))';
  document.body.appendChild(el);
  setTimeout(()=>{ el.style.transition='opacity .3s'; el.style.opacity='0'; }, 1800);
  setTimeout(()=>el.remove(), 2200);
}

/* Drag & Drop */
['dragenter','dragover'].forEach(ev => dropEl.addEventListener(ev, e=>{
  e.preventDefault(); e.stopPropagation(); dropEl.classList.add('drag');
}));
['dragleave','drop'].forEach(ev => dropEl.addEventListener(ev, e=>{
  e.preventDefault(); e.stopPropagation(); dropEl.classList.remove('drag');
}));
dropEl.addEventListener('drop', e=>{
  const dt = e.dataTransfer;
  if(dt && dt.files) addFiles(dt.files);
});
fileInput.addEventListener('change', ()=>{
  if(fileInput.files) addFiles(fileInput.files);
});
dropEl.addEventListener('keydown', e=>{
  if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); fileInput.click(); }
});

/* Progress state */
let artificial = { timer: null, start: 0, dur: 0, softCap: 95, done: false };
let doneCount = 0;
function setInlineProgress(p){ if(progressBar && progressText){ progressBar.style.width = p+'%'; progressText.textContent = p+'%'; } }
function setProgressPage(p){
  progressBar2.style.width = p+'%';
  progressText2.textContent = p+'%';
  if(p >= 100){
    progressTitle.textContent = 'Gotowe';
  } else {
    progressTitle.textContent = 'Pracujemy nad Twoimi plikami…';
  }
}
function setOverallProgress(p){ setInlineProgress(p); setProgressPage(p); }
function startArtificialProgress(ms){
  if(artificial.timer) clearInterval(artificial.timer);
  artificial.start = performance.now();
  artificial.dur = ms;
  artificial.done = false;
  const step = ()=>{
    if(artificial.done) return;
    const t = performance.now() - artificial.start;
    const x = Math.min(1, t / artificial.dur);
    const ease = x*x*(3-2*x);
    const jitter = (Math.random() - 0.5) * 0.06;
    let pct = Math.max(0, Math.min(1, ease + jitter));
    pct = Math.min(pct, artificial.softCap/100);
    const perc = Math.round(pct * 100);
    setProgressPage(perc);
  };
  step();
  artificial.timer = setInterval(step, 200 + Math.random()*220);
}
function completeArtificialProgress(){
  artificial.done = true;
  if(artificial.timer){ clearInterval(artificial.timer); artificial.timer=null; }
}
function updateOverallProgress(){
  const pct = Math.round((doneCount / Math.max(1, files.length)) * 100);
  const curr = parseInt(progressText2.textContent) || 0;
  if(pct > curr) setProgressPage(Math.min(pct, 95));
}

/* Convert controls */
convertBtn.addEventListener('click', async ()=>{
  if(!files.length) return toast('Dodaj pliki', 'warn');

  // Move to progress page immediately
  navigate('progress');
  results = [];
  doneCount = 0;
  setOverallProgress(0);
  updateDownloadLink([]);

  const totalBytes = files.reduce((a,f)=>a+f.size,0);
  startArtificialProgress(Math.min(25000, Math.max(6000, totalBytes / (512*KB) * 1200)));

  const cores = navigator.hardwareConcurrency || 4;
  const concurrency = Math.max(1, Math.min(6, Math.floor(cores/2)));

  const tasks = files.map(f=>()=> convertFile(f, selectedFormat).finally(()=>{ doneCount++; updateOverallProgress(); }));
  await runPool(tasks, concurrency);

  completeArtificialProgress();
  setProgressPage(100);
  updateDownloadLink(results);
  toast('Konwersja zakończona', 'ok');
});

/* Simple pool */
async function runPool(tasks, limit){
  let i = 0;
  const running = new Set();
  return new Promise(resolve=>{
    const next = ()=>{
      if(i >= tasks.length && running.size===0){ resolve(); return; }
      while(running.size < limit && i < tasks.length){
        const p = tasks[i++]();
        running.add(p);
        p.finally(()=>{ running.delete(p); next(); });
      }
    };
    next();
  });
}

/* Convert more / back (reset) */
convertMoreBtn.addEventListener('click', ()=>{
  files = [];
  results = [];
  renderFileList();
  renderResults();
  setOverallProgress(0);
  navigate('home');
  applyCompatibilityLocks();
});

/* Download link */
function updateDownloadLink(items){
  if(!items.length){
    downloadAllBtn.removeAttribute('href');
    downloadAllBtn.removeAttribute('download');
    downloadAllBtn.textContent = 'Pobierz';
    return;
  }
  // If single file, direct download
  if(items.length === 1){
    const first = items[0];
    const url = URL.createObjectURL(first.blob);
    downloadAllBtn.href = url;
    downloadAllBtn.setAttribute('download', first.name);
    downloadAllBtn.textContent = 'Pobierz';
    return;
  }
  // Multi — create lightweight TAR-like pack
  const nameBase = suggestPackBaseName(items);
  const header = new TextEncoder().encode(`CONVERTED-PACK (TAR-LITE)\nItems:${items.length}\nTime:${new Date().toISOString()}\n\n`);
  const parts = [header];
  items.forEach((it, idx)=>{
    const meta = new TextEncoder().encode(`--FILE ${idx+1}-- ${it.name} (${it.blob.type}) size=${it.blob.size}\n`);
    parts.push(meta);
    parts.push(it.blob);
    parts.push(new TextEncoder().encode('\n--END--\n'));
  });
  const pack = new Blob(parts, {type:'application/octet-stream'});
  const url = URL.createObjectURL(pack);
  const filename = `${nameBase}.tar`;
  downloadAllBtn.href = url;
  downloadAllBtn.setAttribute('download', filename);
  downloadAllBtn.textContent = 'Pobierz .tar';
}
function suggestPackBaseName(items){
  if(!items.length) return 'converted';
  const base = commonPrefix(items.map(i=>i.name.replace(/\.[^.]+$/,''))).trim();
  if(base && base.length >= 3) return base + '-converted';
  return 'converted';
}
function commonPrefix(arr){
  if(!arr.length) return '';
  let p = arr[0];
  for(let i=1;i<arr.length;i++){
    let j=0; const s = arr[i];
    while(j < p.length && j < s.length && p[j]===s[j]) j++;
    p = p.slice(0,j);
    if(!p) break;
  }
  return p.replace(/[-_. ]+$/,'');
}

/* Core converters */
async function convertFile(file, fmt){
  const cat = (extToCategory[(file.name.split('.').pop()||'').toLowerCase()] || selectedCategory);
  try{
    let out;
    if(cat === 'image'){
      out = await convertImage(file, fmt);
    }else if(cat === 'audio'){
      out = await convertAudio(file, fmt);
    }else if(cat === 'document'){
      out = await convertDocument(file, fmt);
    }else if(cat === 'video'){
      out = await convertVideo(file, fmt);
    }else if(cat === 'archive'){
      out = await convertArchive(file, fmt);
    }else if(cat === 'code'){
      out = await convertCode(file, fmt);
    }else{
      out = new Blob([await file.arrayBuffer()], {type: file.type || 'application/octet-stream'});
    }
    const base = file.name.replace(/\.[^.]+$/,'');
    const name = `${base}.${suggestExt(fmt, file.name)}`;
    results.push({name, blob: out, type: out.type || 'application/octet-stream'});
  }catch(err){
    console.error(err);
    toast(`Niepowodzenie: ${file.name}`, 'err');
  }
}

/* Image */
async function convertImage(file, fmt){
  // Vector/icon lite outputs
  if(fmt==='svg-lite'){
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="800" height="480"><defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#22d3ee"/><stop offset="1" stop-color="#a78bfa"/></linearGradient></defs><rect width="100%" height="100%" fill="url(#g)"/><text x="24" y="48" font-size="28" font-family="system-ui" fill="#fff">Wygenerowany SVG (lite)</text></svg>`;
    return new Blob([svg], {type:'image/svg+xml'});
  }
  if(fmt==='ico-lite'){
    const {blob} = await generatePlaceholderCanvas(64, 64, 'image/png');
    return new Blob([await blob.arrayBuffer()], {type:'image/x-icon'});
  }
  if(fmt==='bmp-lite'){
    const {blob} = await generatePlaceholderCanvas(480, 300, 'image/png');
    return new Blob([await blob.arrayBuffer()], {type:'image/bmp'});
  }

  const buf = await file.arrayBuffer();
  const blobUrl = URL.createObjectURL(new Blob([buf]));
  const img = await loadImage(blobUrl).catch(()=>null);
  URL.revokeObjectURL(blobUrl);

  const mime = fmtToMime(fmt);
  if(!img){
    const {blob} = await generatePlaceholderCanvas(800, 500, mime);
    return blob;
  }

  const limitMP = (navigator.deviceMemory || 4) >= 8 ? 24 : 10;
  const maxPixels = limitMP * 1_000_000;
  const scale = Math.min(1, Math.sqrt(maxPixels / (img.naturalWidth * img.naturalHeight)));
  const w = Math.max(1, Math.round(img.naturalWidth * scale));
  const h = Math.max(1, Math.round(img.naturalHeight * scale));

  const can = document.createElement('canvas');
  can.width = w; can.height = h;
  const ctx = can.getContext('2d');
  const opaque = (fmt==='jpeg' || fmt==='jpg' || fmt==='jpeg-low');
  if(opaque){
    const grd = ctx.createLinearGradient(0,0,w,h);
    grd.addColorStop(0,'#0d1117'); grd.addColorStop(1,'#1b2735');
    ctx.fillStyle = grd; ctx.fillRect(0,0,w,h);
  }
  ctx.drawImage(img, 0, 0, w, h);

  let quality = 0.9;
  if(fmt==='jpeg-low') quality = 0.5;

  if(fmt==='png-8'){
    const b = await new Promise(r=>can.toBlob(r, 'image/png', 0.8));
    return b || new Blob([buf], {type: 'image/png'});
  }

  const b = await new Promise(r=>can.toBlob(r, mime, quality));
  return b || new Blob([buf], {type: mime});
}
function fmtToMime(fmt){
  const m = {
    png: 'image/png',
    'png-8':'image/png',
    jpeg: 'image/jpeg',
    'jpeg-low':'image/jpeg',
    jpg: 'image/jpeg',
    webp: 'image/webp',
    avif: 'image/avif',
    'gif-lite': 'image/gif',
    gif: 'image/gif',
    'webm-lite': 'video/webm',
    webm: 'video/webm',
    'thumb-webp':'image/webp',
    mp3: 'audio/mpeg',
    m4a: 'audio/mp4',
    ogg: 'audio/ogg',
    flac:'audio/flac',
    opus:'audio/opus',
    mp4: 'video/mp4',
    mov: 'video/quicktime',
    wav: 'audio/wav',
    'pdf-lite':'application/pdf',
    'rtf-lite':'application/rtf',
    'html-lite':'text/html',
    'zip-lite':'application/zip',
    'tar-lite':'application/x-tar',
    json:'application/json',
    csv:'text/csv',
    txt:'text/plain',
    md:'text/markdown',
    'svg-lite':'image/svg+xml',
    'bmp-lite':'image/bmp',
    'ico-lite':'image/x-icon',
    'ndjson-lite':'application/x-ndjson'
  };
  return m[fmt] || 'application/octet-stream';
}
function loadImage(url){
  return new Promise((res, rej)=>{
    const img = new Image();
    img.onload = ()=> res(img);
    img.onerror = rej;
    img.crossOrigin = 'anonymous';
    img.src = url;
  });
}

/* Audio */
async function convertAudio(file, fmt){
  if(['mp3','m4a','ogg','flac','opus'].includes(fmt)){
    try{ return await ffmpegConvert(file, fmt); }
    catch(e){ console.warn('FFmpeg audio failed, fallback to WAV:', e); }
  }
  const array = await file.arrayBuffer();
  let audioBuf = null;
  try{
    const ac = new (window.AudioContext || window.webkitAudioContext)({sampleRate: 48000});
    audioBuf = await ac.decodeAudioData(array.slice(0));
    ac.close();
  }catch{}
  if(!audioBuf){ return await synthToneTo(fmt==='wav'?'wav':'wav'); }
  if(fmt === 'wav') return pcmToWavBlob(audioBuf);
  return pcmToWavBlob(audioBuf);
}
async function synthToneTo(format='wav'){
  const sr = 48000, dur = 0.5, len = Math.floor(sr*dur);
  const ac = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, len, sr);
  const osc = ac.createOscillator(); osc.type = 'sine'; osc.frequency.value = 440;
  const gain = ac.createGain(); gain.gain.value = 0.2;
  osc.connect(gain).connect(ac.destination);
  osc.start(0); osc.stop(dur);
  const buf = await ac.startRendering();
  const wav = await pcmToWavBlob(buf);
  return wav;
}
function pcmToWavBlob(audioBuffer){
  const numOfChan = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const samples = audioBuffer.length;
  const bytesPerSample = 2;
  const blockAlign = numOfChan * bytesPerSample;
  const dataSize = samples * blockAlign;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  const writeStr = (o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
  let off = 0;
  writeStr(off,'RIFF'); off+=4;
  view.setUint32(off, 36+dataSize, true); off+=4;
  writeStr(off,'WAVE'); off+=4;
  writeStr(off,'fmt '); off+=4;
  view.setUint32(off, 16, true); off+=4;
  view.setUint16(off, 1, true); off+=2;
  view.setUint16(off, numOfChan, true); off+=2;
  view.setUint32(off, sampleRate, true); off+=4;
  view.setUint32(off, sampleRate*blockAlign, true); off+=4;
  view.setUint16(off, blockAlign, true); off+=2;
  view.setUint16(off, bytesPerSample*8, true); off+=2;
  writeStr(off,'data'); off+=4;
  view.setUint32(off, dataSize, true); off+=4;
  const channels = [];
  for(let ch = 0; ch < numOfChan; ch++) channels.push(audioBuffer.getChannelData(ch));
  let idx = 0;
  for(let i=0; i<samples; i++){
    for(let ch=0; ch<numOfChan; ch++){
      const s = Math.max(-1, Math.min(1, channels[ch][i]));
      view.setInt16(44 + idx, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      idx += 2;
    }
  }
  return new Blob([view], {type:'audio/wav'});
}

/* Document */
async function convertDocument(file, fmt){
  const text = await tryReadText(file);
  if(fmt==='txt') return new Blob([text], {type:'text/plain'});
  if(fmt==='md'){
    const md = `# Przekonwertowany dokument\n\nOryginał: ${file.name}\n\n---\n\n${text}`;
    return new Blob([md], {type:'text/markdown'});
  }
  if(fmt==='html-lite'){
    const safe = escapeHTML(text).slice(0, 20000).replace(/\n/g,'<br>');
    const html = `<!doctype html><meta charset="utf-8"><title>${escapeHTML(file.name)}</title><style>body{font-family:system-ui;margin:20px;line-height:1.5}</style><h1>${escapeHTML(file.name)}</h1><div>${safe}</div>`;
    return new Blob([html], {type:'text/html'});
  }
  if(fmt==='pdf-lite'){
    const pdfBytes = generateMiniPDF(text.slice(0, 20000));
    return new Blob([pdfBytes], {type:'application/pdf'});
  }
  if(fmt==='rtf-lite'){
    const rtf = `{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0 Helvetica;}}\\fs20 Przekonwertowano z ${escapeRTF(file.name)}\\par ${escapeRTF(text.slice(0,5000))}}`;
    return new Blob([rtf], {type:'application/rtf'});
  }
  return new Blob([text], {type:'text/plain'});
}
function escapeRTF(s){ return s.replace(/[\\{}]/g, m=> '\\'+m).replace(/\n/g,'\\par '); }
function escapeHTML(s){ return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
async function tryReadText(file){
  try{ return await file.text(); }
  catch{
    const buf = await file.arrayBuffer();
    try{ return new TextDecoder().decode(buf); }
    catch{ return '[dane binarne]'; }
  }
}

/* Video */
async function convertVideo(file, fmt){
  if(['mp4','webm','gif','mov'].includes(fmt)){
    try{ return await ffmpegConvert(file, fmt); }
    catch(e){ console.warn('FFmpeg video conversion failed, fallback to thumbnails:', e); }
  }
  // Lite modes and fallbacks
  let frames = [];
  try{
    const blobUrl = URL.createObjectURL(file);
    const vid = document.createElement('video');
    vid.muted = true; vid.src = blobUrl; vid.preload = 'auto';
    await vid.play().catch(()=>{});
    await once(vid, 'loadeddata', 2000).catch(()=>{});
    const dur = isFinite(vid.duration) ? vid.duration : 3;
    const w = Math.min(640, vid.videoWidth || 320);
    const h = Math.round((vid.videoHeight||180) * (w/(vid.videoWidth||320)));
    const can = document.createElement('canvas');
    can.width = w; can.height = h;
    const ctx = can.getContext('2d');
    const sampleFrames = 10;
    for(let i=0;i<sampleFrames;i++){
      const t = (dur * i) / sampleFrames;
      vid.currentTime = t;
      await once(vid,'seeked', 800).catch(()=>{});
      ctx.drawImage(vid, 0, 0, w, h);
      const frame = await new Promise(r=>can.toBlob(b=>r(b),'image/webp',0.85));
      if(frame) frames.push(frame);
    }
    URL.revokeObjectURL(blobUrl);
  }catch(e){ frames = []; }
  if(!frames.length) frames = await synthFrames(10, 360, 200);

  if(fmt === 'gif-lite'){
    const concat = await concatBlobs(frames, 'image/webp');
    return new Blob([await concat.arrayBuffer()], {type:'image/gif'});
  }
  if(fmt === 'webm-lite'){
    return new Blob([await frames[0].arrayBuffer()], {type:'video/webm'});
  }
  if(fmt === 'thumb-webp'){
    return frames[0];
  }
  return new Blob([await frames[0].arrayBuffer()], {type:'video/webm'});
}

/* Archive (lite) */
async function convertArchive(file, fmt){
  if(fmt==='tar-lite'){
    const header = new TextEncoder().encode(`TAR-LITE\nPlik:${file.name}\nRozmiar:${file.size}\nUtworzono:${new Date().toISOString()}\n\n`);
    const content = await file.arrayBuffer();
    return new Blob([header, content], {type:'application/x-tar'});
  }
  if(fmt==='zip-lite'){
    const header = new TextEncoder().encode(`ZIP-LITE\nPlik:${file.name}\nRozmiar:${file.size}\nUtworzono:${new Date().toISOString()}\n\n`);
    const content = await file.arrayBuffer();
    return new Blob([header, content], {type:'application/zip'});
  }
  return new Blob([await file.arrayBuffer()], {type:'application/octet-stream'});
}

/* Code */
async function convertCode(file, fmt){
  const text = await tryReadText(file);
  if(fmt==='json'){
    try{
      const obj = JSON.parse(text);
      return new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
    }catch{
      return new Blob([JSON.stringify({raw:text})], {type:'application/json'});
    }
  }
  if(fmt==='csv'){
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    const csv = lines.map(l => l.split(/\s+/).map(cell => /[",\n]/.test(cell)?('"'+cell.replace(/"/g,'""')+'"'):cell).join(',')).join('\n');
    return new Blob([csv], {type:'text/csv'});
  }
  if(fmt==='ndjson-lite'){
    const lines = text.split(/\r?\n/).filter(Boolean).map((v,i)=>({i, value:v}));
    const out = lines.map(obj=>JSON.stringify(obj)).join('\n');
    return new Blob([out], {type:'application/x-ndjson'});
  }
  return new Blob([text], {type:'text/plain'});
}

/* Utilities */
function truncate(str, n){
  if(str.length <= n) return str;
  const ext = (str.includes('.') ? '.'+str.split('.').pop() : '');
  const base = str.slice(0, Math.max(0, n - ext.length - 1));
  return base + '…' + ext;
}
function once(target, event, timeoutMs=0){
  return new Promise((res, rej)=>{
    const on = ()=>{ cleanup(); res(); };
    const to = timeoutMs ? setTimeout(()=>{ cleanup(); rej(new Error('timeout')); }, timeoutMs) : null;
    const cleanup = ()=>{ target.removeEventListener(event, on); if(to) clearTimeout(to); };
    target.addEventListener(event, on, {once:true});
  });
}
async function synthFrames(n, w, h){
  const frames = [];
  const can = document.createElement('canvas');
  can.width = w; can.height = h;
  const ctx = can.getContext('2d');
  for(let i=0;i<n;i++){
    const t = i / Math.max(1, n-1);
    const g = ctx.createLinearGradient(0,0,w,h);
    const c1 = `hsl(${Math.round(200+120*t)} 80% 50%)`;
    const c2 = `hsl(${Math.round(280+80*t)} 80% 60%)`;
    g.addColorStop(0, c1); g.addColorStop(1, c2);
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
    ctx.fillStyle = 'rgba(0,0,0,.35)'; ctx.fillRect(20, h-40, 160, 24);
    ctx.fillStyle = 'white'; ctx.font = 'bold 14px system-ui, sans-serif';
    ctx.fillText(`Klatka ${i+1}`, 26, h-24);
    const b = await new Promise(r=>can.toBlob(r,'image/webp',0.9));
    if(b) frames.push(b);
  }
  return frames;
}
async function concatBlobs(blobs, type){
  const parts = [];
  for(const b of blobs) parts.push(new Uint8Array(await b.arrayBuffer()));
  const len = parts.reduce((a,p)=>a+p.byteLength,0);
  const out = new Uint8Array(len);
  let off = 0;
  for(const p of parts){ out.set(p, off); off += p.byteLength; }
  return new Blob([out], {type});
}
async function generatePlaceholderCanvas(w, h, mime='image/png'){
  const can = document.createElement('canvas');
  can.width = w; can.height = h;
  const ctx = can.getContext('2d');
  const g = ctx.createLinearGradient(0,0,w,h);
  g.addColorStop(0, '#0ea5e9'); g.addColorStop(1, '#8b5cf6');
  ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
  ctx.fillStyle = 'rgba(255,255,255,.85)';
  ctx.font = 'bold 28px system-ui, sans-serif';
  ctx.fillText('Wygenerowana grafika', 24, 48);
  const blob = await new Promise(r=>can.toBlob(r, mime, 0.92));
  return {blob, canvas: can};
}
function generateMiniPDF(text){
  const esc = s => s.replace(/[\$$)]/g, m=> '\\'+m).replace(/\r?\n/g,'\\n');
  const lines = text.split(/\r?\n/).slice(0, 80);
  const content = [];
  content.push('BT /F1 12 Tf 50 780 Td 14 TL');
  for(const ln of lines){
    const t = esc(ln).slice(0, 100);
    content.push('('+t+') Tj T*');
  }
  content.push('ET');
  const contentStream = content.join('\n');

  const objects = [];
  function addObject(str){ objects.push(str); }
  addObject('1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj');
  addObject('2 0 obj << /Type /Pages /Kids [3 0 R] /Count 1 >> endobj');
  addObject('3 0 obj << /Type /Page /Parent 2 0 R /MediaBox [0 0 595 842] /Resources << /Font << /F1 4 0 R >> >> /Contents 5 0 R >> endobj');
  addObject('4 0 obj << /Type /Font /Subtype /Type1 /BaseFont /Helvetica >> endobj');
  addObject(`5 0 obj << /Length ${contentStream.length} >> stream
${contentStream}
endstream endobj`);

  let pdf = '%PDF-1.4\n';
  const offsets = [];
  for(const obj of objects){
    offsets.push(pdf.length);
    pdf += obj + '\n';
  }
  const xrefPos = pdf.length;
  pdf += 'xref\n0 ' + (objects.length+1) + '\n';
  pdf += '0000000000 65535 f \n';
  for(const off of offsets){
    pdf += String(off).padStart(10,'0') + ' 00000 n \n';
  }
  pdf += `trailer << /Size ${objects.length+1} /Root 1 0 R >>\nstartxref\n${xrefPos}\n%%EOF`;
  return new TextEncoder().encode(pdf);
}
function suggestExt(fmt, originalName){
  const map = {
    'pdf-lite':'pdf','gif-lite':'gif','webm-lite':'webm','png-8':'png',
    'jpeg-low':'jpg','rtf-lite':'rtf','zip-lite':'zip','tar-lite':'tar',
    'thumb-webp':'webp','svg-lite':'svg','bmp-lite':'bmp','ico-lite':'ico',
    'html-lite':'html','ndjson-lite':'ndjson'
  };
  const ext = map[fmt] || fmt.toLowerCase();
  const oext = (originalName.split('.').pop()||'').toLowerCase();
  if(ext===oext) return ext;
  return ext;
}

/* Init */
function init(){
  const autoLimit = estimateSafeLimitBytes();
  const info = $('#limitInfo');
  if(info){
    info.innerHTML = `<span class="status">Automatyczny limit: ${humanSize(autoLimit)}</span>`;
  }
  buildFormatUI();
  renderResults();
  onFilesChanged();
}
init();
</script>
</body>
</html>

